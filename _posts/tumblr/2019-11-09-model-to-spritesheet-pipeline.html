---
layout: post
title: Model to Spritesheet Pipeline
date: '2019-11-09T18:33:15-05:00'
tags:
- colonycaseus
tumblr_url: https://boxfishdev.tumblr.com/post/188936046409/model-to-spritesheet-pipeline
---
<p>Been pretty busy, which is why there was no post last week. Today, I wanna talk about my 3d model to spritesheet pipeline. I realized while creating my second enemy that manually creating every enemy animation would take way more time and effort than it’s worth. Every time I want an enemy to do a new action (and there’s a lot for them to do, from spawning to idling to dying), I’d have to create an animation for every direction the enemy faces. I’m also not the&hellip; best pixel artist, so a lack of precise artistic control isn’t an issue for me. That’s why I drew up this:<br/></p><figure data-orig-width="1453" data-orig-height="656" class="tmblr-full"><img src="https://66.media.tumblr.com/cf7b59180457f6cf9e52be8fcf4ef0d5/ee222eca0a40be78-a7/s540x810/8e0bd238dd782d318e6fef2de8e6b19b30f473ff.jpg" alt="image" data-orig-width="1453" data-orig-height="656"/></figure><p>For people without magnifying glasses handy, here’s what the flowchart basically says:</p><ol><li>We start off with a template Blender file. The template comes with four cameras (one for each direction) and a square tile (a reference to in-game floor tiles). The enemy gets modelled and animated, as one does.</li><li>In Blender, a script iterates over every camera and renders every animation, storing the renders in an “output” folder. Inside the output folder, renders are grouped by animation and direction (ex: a walk cycle facing right-down would be placed in “output/walk/RD/”).</li><li>A second script goes over every render in the output folder and splices them into a spritesheet. In the process, a json file gets generated that details the animations and the indices of the sprites they use.</li><li>A third script takes the output file and spritesheet and generates a file representing an enemy’s moveset (see the post on the Enemy Editor). Now, hitboxes and offsets can be defined from the editor.</li></ol><p>This already would save me a ton of time. There’s just one issue, though. If I had to go back and define new animations or add new frames to old ones, my enemy file would get overwritten, and I’d have to define my hitboxes and offsets all over again. So as a last step, a script should take the old enemy file and the new enemy file and merge them so the sprite data gets updated, while the other data gets kept.</p><p>This sounds pretty simple, but how easy was it to implement in practice? Actually, it wasn’t that bad.</p><figure data-orig-width="1337" data-orig-height="651" class="tmblr-full"><img src="https://66.media.tumblr.com/e042d94ef979ac26129a086c649e1f99/ee222eca0a40be78-67/s540x810/c298696632de65309d94e584ff60f99950e96376.png" alt="image" data-orig-width="1337" data-orig-height="651"/></figure><p>Step 1: Creating a template file. I was playing around with Blender to test out the idea, so I already had a sample file ready. I just removed the enemy model and animations and was good to go.</p><figure data-orig-width="971" data-orig-height="380" class="tmblr-full"><img src="https://66.media.tumblr.com/0aec879e2b96a84efae36a63e72883fa/ee222eca0a40be78-be/s540x810/adbff54e1bf653a8978b9be32d4c8642082c7111.png" alt="image" data-orig-width="971" data-orig-height="380"/></figure><p>Step 2: Scripting Blender to render everything. I thought this would be a big hassle, but props to the Blender team for designing such a tight Python API. I just had to go over the cameras and animations, change the output directory for each animation, and render. I think it took about 10 lines to get what I needed.</p><figure data-orig-width="766" data-orig-height="460" class="tmblr-full"><img src="https://66.media.tumblr.com/df1ef81d196ceec28f64b0ae8a2eeeec/ee222eca0a40be78-59/s540x810/89e6e18f983cf8aed2fd6d040c972341167b606d.png" alt="image" data-orig-width="766" data-orig-height="460"/></figure><p>Step 3: Generating a sprite sheet. I used Python with the Pillow image library for this one. First, I went over every render in the output folder and copied it over to a new folder. In the process, I renamed the image to the sprite index it would become (so the first render is 0.png, the next 1.png&hellip;). Then, I went over every renamed render and pasted it into an empty image. I also took note of which sprites represented which animation and saved it into a JSON file.</p><figure data-orig-width="829" data-orig-height="744" class="tmblr-full"><img src="https://66.media.tumblr.com/e9c1c42c44c158edccc35b3a73046b77/ee222eca0a40be78-0e/s540x810/70d5cfed5aca10a4d6285f9a82f07622eb09ed03.png" alt="image" data-orig-width="829" data-orig-height="744"/></figure><p>Step 4: Generating an enemy file. Basically, I just had to convert the info in the JSON file to XML, which is what my enemy file is structured in. Not a very hard task.</p><figure data-orig-width="1689" data-orig-height="847" class="tmblr-full"><img src="https://66.media.tumblr.com/0212bee584b2d81a0208b32018338d19/ee222eca0a40be78-57/s540x810/423eb03450d7c3f2e48fd76d82b2e57007fe76c8.png" alt="image" data-orig-width="1689" data-orig-height="847"/></figure><p>Step 5: Merging the old and new enemy files. This one, I feel, was the hardest part. First, I read in both old and new enemy files. If no old enemy file existed, I copied the new file over to where the old file should be and quit. If it did exist, I iterated over every move and copied the properties from the old file to the new one.</p><p>All in all, I was able to finish everything in about a weekend! My only concern now is making the renders look natural, as if they were hand drawn. Or rather, hand pixelled. Blender’s built in shader pipeline is pretty nice, though, so I&rsquo;m looking forward to playing around with that.<br/></p>
